<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mehran Tajbakhsh">

<title>Anomaly Detection in Network Traffic Using NSL-KDD Dataset – Final Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-707d8167ce6003fca903bfe2be84ab7f.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ffa9a6279353761231ec249df0a7fdd3.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-24772959a0e306aba8d7698078628ce7.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="site_libs/bootstrap/bootstrap-ffa9a6279353761231ec249df0a7fdd3.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Final Project</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./proposal.html"> 
<span class="menu-text">Proposal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./presentation.html" aria-current="page"> 
<span class="menu-text">Presentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/INFO-523-SU24/final-project"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-motivation" id="toc-introduction-motivation" class="nav-link active" data-scroll-target="#introduction-motivation">Introduction &amp; Motivation</a></li>
  <li><a href="#problem-statement" id="toc-problem-statement" class="nav-link" data-scroll-target="#problem-statement">Problem Statement</a></li>
  <li><a href="#background" id="toc-background" class="nav-link" data-scroll-target="#background">Background</a></li>
  <li><a href="#dataset-overview" id="toc-dataset-overview" class="nav-link" data-scroll-target="#dataset-overview">Dataset Overview</a></li>
  <li><a href="#methodology" id="toc-methodology" class="nav-link" data-scroll-target="#methodology">Methodology</a></li>
  <li><a href="#unsupervised-results-statistical" id="toc-unsupervised-results-statistical" class="nav-link" data-scroll-target="#unsupervised-results-statistical">Unsupervised Results: Statistical</a></li>
  <li><a href="#unsupervised-results-advanced" id="toc-unsupervised-results-advanced" class="nav-link" data-scroll-target="#unsupervised-results-advanced">Unsupervised Results: Advanced</a></li>
  <li><a href="#supervised-results-models" id="toc-supervised-results-models" class="nav-link" data-scroll-target="#supervised-results-models">Supervised Results: Models</a></li>
  <li><a href="#supervised-results-explainability" id="toc-supervised-results-explainability" class="nav-link" data-scroll-target="#supervised-results-explainability">Supervised Results: Explainability</a></li>
  <li><a href="#model-performance-summary" id="toc-model-performance-summary" class="nav-link" data-scroll-target="#model-performance-summary">Model Performance Summary</a></li>
  <li><a href="#models-comparison" id="toc-models-comparison" class="nav-link" data-scroll-target="#models-comparison">Models Comparison</a></li>
  <li><a href="#discussion" id="toc-discussion" class="nav-link" data-scroll-target="#discussion">Discussion</a></li>
  <li><a href="#discussion-1" id="toc-discussion-1" class="nav-link" data-scroll-target="#discussion-1">Discussion</a></li>
  <li><a href="#discussion-2" id="toc-discussion-2" class="nav-link" data-scroll-target="#discussion-2">Discussion</a></li>
  <li><a href="#overall-trade-off" id="toc-overall-trade-off" class="nav-link" data-scroll-target="#overall-trade-off">Overall Trade-Off</a></li>
  <li><a href="#real-world-implications" id="toc-real-world-implications" class="nav-link" data-scroll-target="#real-world-implications">Real-World Implications</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="presentation.html"><i class="bi bi-file-slides"></i>RevealJS</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Anomaly Detection in Network Traffic Using NSL-KDD Dataset</h1>
<p class="subtitle lead">INFO 523 - Fall 2025 - Final Project</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mehran Tajbakhsh </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introduction-motivation" class="level2 scrollable page-columns page-full" data-background-gradient="linear-gradient(to bottom, #283b95, 17b2c3)" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-background-gradient="linear-gradient(to bottom, #283b95, 17b2c3)" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="introduction-motivation">Introduction &amp; Motivation</h2>
<ul>
<li>Rising <strong>network complexity</strong></li>
<li>Expanding <strong>attack surface</strong></li>
<li>Need for <strong>adaptive detection</strong></li>
<li>Limits of <strong>signature systems</strong></li>
<li>Value of <strong>behavioral analytics</strong></li>
<li>Goal: improved <strong>threat identification</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>This project is motivated by the growing complexity of modern networks and the expanding attack surface that organizations face. Traditional signature-based detection struggles to keep pace with evolving and previously unseen threats. By shifting toward adaptive, behavior-based analytics, we can identify abnormal activity earlier and more accurately. The overall objective is to strengthen threat detection capabilities and improve security decision-making at scale.</p>
</div></div></section>
<section id="problem-statement" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="problem-statement">Problem Statement</h2>
<ul>
<li>Identify limits of current <strong>anomaly detection</strong> approaches</li>
<li>Assess ability to detect <strong>malicious network behavior</strong></li>
<li>Compare <strong>unsupervised</strong>, <strong>statistical</strong>, and <strong>supervised</strong> methods</li>
<li>Evaluate differences in <strong>detection effectiveness</strong></li>
<li>Understand variation in <strong>precision</strong>, <strong>recall</strong>, and false alerts</li>
<li>Determine most reliable model for <strong>operational deployment</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>The goal is to understand how different detection methods perform when identifying malicious activity in complex network environments. We evaluate traditional statistical models, modern unsupervised anomaly detectors, and supervised machine-learning approaches to determine their strengths and limitations. The focus is on how accurately these methods detect threats, how often they generate false alerts, and how interpretable their outputs are for analysts. Ultimately, the aim is to determine which approach provides the most reliable and operationally effective intrusion detection capability.</p>
</div></div></section>
<section id="background" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="background">Background</h2>
<ul>
<li>Expanding <strong>cyberattack landscape</strong></li>
<li>Importance of <strong>anomaly detection</strong></li>
<li>Mix of <strong>statistical</strong> and <strong>ML</strong> tools**</li>
<li>Challenge of <strong>imbalanced attacks</strong></li>
<li>Need for <strong>explainability</strong></li>
<li>Relevance to modern <strong>SOCs</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>Cyberattacks continue to grow in scale and sophistication, making traditional rule-based detection insufficient. Anomaly detection is increasingly important because it can surface unusual or emerging behaviors that signatures fail to capture. Our evaluation spans both statistical techniques and machine-learning models, each offering different strengths. A major challenge in this domain is the imbalance between normal traffic and rare attack events, which can distort model performance. Explainability is also essential so analysts can trust and validate detection outputs. These considerations directly impact how Security Operations Centers operate and prioritize alerts.</p>
</div></div></section>
<section id="dataset-overview" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="dataset-overview">Dataset Overview</h2>
<ul>
<li><strong>NSL-KDD</strong> standard dataset</li>
<li>41 engineered <strong>network features</strong></li>
<li>Balanced <strong>training/test</strong> sets</li>
<li>Multiple <strong>attack categories</strong></li>
<li>Supports <strong>binary</strong> and <strong>multi-class</strong> tasks</li>
<li>Widely used for <strong>IDS research</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>The NSL-KDD dataset is a widely used benchmark for intrusion detection research and is designed to address some of the limitations in the original KDD’99 dataset, such as redundant records. It contains 41 engineered network features and multiple attack categories, enabling both binary and multi-class evaluation. For this project, we used the 10% version of the dataset, which provides a representative but computationally manageable subset of the full collection. The data comes from the University of New Brunswick’s Canadian Institute for Cybersecurity repository, which maintains standardized, research-grade network security datasets.</p>
</div></div></section>
<section id="methodology" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="methodology">Methodology</h2>
<ul>
<li>Standard pipeline: <strong>EDA</strong> → <strong>preprocessing</strong> → <strong>modeling</strong> → <strong>evaluation</strong></li>
<li>Data <strong>cleaning</strong>, <strong>encoding</strong>, and <strong>scaling</strong></li>
<li>Unsupervised: <strong>Z-score</strong>, <strong>IQR</strong>, <strong>Elliptic</strong>, <strong>Mahalanobis</strong></li>
<li>Advanced: <strong>Isolation Forest</strong>, <strong>LOF</strong>, <strong>Autoencoder</strong></li>
<li>Supervised: <strong>RF</strong>, <strong>SVM</strong>, <strong>LogReg</strong></li>
<li>Evaluated using <strong>accuracy</strong>, <strong>precision</strong>, <strong>recall</strong>, <strong>F1</strong>, <strong>AUC</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>Our workflow follows a standard machine learning pipeline beginning with exploratory data analysis, followed by preprocessing steps such as cleaning, encoding, and scaling. We implemented a range of models, starting with statistical and unsupervised anomaly detectors, then moving to more advanced techniques like Isolation Forest, Local Outlier Factor, and Autoencoders. Supervised models, including Random Forest, SVM, and Logistic Regression, were trained using the labeled portions of the dataset. All models were evaluated using consistent metrics—accuracy, precision, recall, F1, and AUC—to ensure a fair comparison across approaches.</p>
</div></div></section>
<section id="unsupervised-results-statistical" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="unsupervised-results-statistical">Unsupervised Results: Statistical</h2>
<ul>
<li><strong>Z-score</strong> detects extreme deviations</li>
<li><strong>IQR</strong> captures distribution outliers</li>
<li><strong>Elliptic Envelope</strong> robust covariance</li>
<li><strong>Mahalanobis</strong> multivariate distance</li>
<li>High <strong>false-positive</strong> variability</li>
<li>Limited subtle <strong>attack detection</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>These traditional statistical methods provide fast and lightweight anomaly detection but have clear limitations. Z-score and IQR rely on simple distribution thresholds, so they mainly detect very large deviations and miss more nuanced behaviors. Elliptic Envelope and Mahalanobis distance incorporate covariance structure, offering a more sophisticated view of normal traffic, but they still struggle with the complexity and variability of real attack patterns. Across all of these methods, we observed high false-positive rates and inconsistent performance, especially when the anomalies were subtle or closely resembled normal traffic. This highlights the need for more advanced models in operational environments.</p>
</div></div></section>
<section id="unsupervised-results-advanced" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="unsupervised-results-advanced">Unsupervised Results: Advanced</h2>
<ul>
<li><strong>Isolation Forest</strong> strong separation</li>
<li><strong>LOF</strong> local-density anomalies</li>
<li><strong>Autoencoder</strong> learns latent structure</li>
<li>Outperforms statistical baselines</li>
<li>Lower recall for <strong>stealth attacks</strong></li>
<li>Needs <strong>threshold tuning</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>These advanced unsupervised models deliver noticeably better performance than the simpler statistical methods. Isolation Forest is effective at separating anomalies by isolating rare behaviors, while LOF focuses on local density differences to detect unusual patterns in small regions of the feature space. The Autoencoder, which learns compressed representations of normal traffic, performed the strongest among the unsupervised approaches and was able to capture complex relationships between features. However, all these models still showed limitations, particularly with low-signal or stealthy attacks that closely resemble normal activity. Their performance is also highly sensitive to threshold settings, meaning operational tuning is essential for reliable detection.</p>
</div></div></section>
<section id="supervised-results-models" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="supervised-results-models">Supervised Results: Models</h2>
<ul>
<li><strong>Random Forest</strong> best performance</li>
<li>High <strong>precision</strong> and <strong>recall</strong></li>
<li><strong>SVM-RBF</strong> competitive results</li>
<li>Logistic baseline comparison</li>
<li>Clear attack <strong>class separation</strong></li>
<li>Stable across <strong>test folds</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>Supervised learning clearly provided the strongest results in this evaluation. Random Forest delivered the best overall performance with consistently high precision and recall, making it the most reliable model for distinguishing normal and malicious traffic. The SVM with an RBF kernel also performed competitively, especially on nonlinear patterns, while Logistic Regression served as a baseline for comparison. These models showed clear separation between attack classes and demonstrated stable behavior across multiple test folds, reinforcing their suitability for operational intrusion detection when labeled data is available.</p>
</div></div></section>
<section id="supervised-results-explainability" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="supervised-results-explainability">Supervised Results: Explainability</h2>
<ul>
<li>Random Forest feature <strong>importance clarity</strong></li>
<li>Identify top <strong>predictive fields</strong></li>
<li>SVM <strong>decision boundary</strong> insights</li>
<li>Enhanced analyst <strong>trust</strong></li>
<li>Supports security <strong>auditability</strong></li>
<li>Reduces black-box <strong>risk</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>A key advantage of the supervised models—especially Random Forest and SVM—is their interpretability. Random Forest provides clear feature-importance rankings, helping analysts understand which network attributes contribute most to attack detection. SVM models offer insights into decision boundaries, clarifying how the classifier separates malicious and normal behavior. These interpretability tools improve analyst trust, support auditing and compliance requirements, and reduce the risks associated with deploying opaque, black-box detection systems. For an operational SOC, this level of transparency is essential for validating alerts and refining detection strategies.</p>
</div></div></section>
<section id="model-performance-summary" class="level2" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 data-transition="fade-in slide-out" data-transition-speed="slow" class="anchored" data-anchor-id="model-performance-summary">Model Performance Summary</h2>
<div>

<table class="dataframe table table-sm table-striped small">
<thead>
<tr>
<th>
</th>
<th>
model
</th>
<th>
precision_macro
</th>
<th>
recall_macro
</th>
<th>
f1_macro
</th>
<th>
roc_auc_ovr_macro
</th>
<th>
pr_auc_ovr_macro
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
Random Forest (baseline)
</td>
<td>
0.962361
</td>
<td>
0.974293
</td>
<td>
0.967920
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
1
</th>
<td>
Random Forest + SMOTE
</td>
<td>
0.947867
</td>
<td>
0.975182
</td>
<td>
0.960155
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
2
</th>
<td>
SVM-RBF + SMOTE
</td>
<td>
0.890610
</td>
<td>
0.930098
</td>
<td>
0.905367
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
3
</th>
<td>
SVM-RBF (baseline)
</td>
<td>
0.642394
</td>
<td>
0.722858
</td>
<td>
0.501165
</td>
<td>
NaN
</td>
<td>
NaN
</td>
</tr>
<tr>
<th>
4
</th>
<td>
Z-Score
</td>
<td>
1.000000
</td>
<td>
1.000000
</td>
<td>
1.000000
</td>
<td>
1.000000
</td>
<td>
1.000000
</td>
</tr>
<tr>
<th>
5
</th>
<td>
OC-SVM (RBF)
</td>
<td>
0.779636
</td>
<td>
1.000000
</td>
<td>
0.876175
</td>
<td>
0.962972
</td>
<td>
0.779636
</td>
</tr>
<tr>
<th>
6
</th>
<td>
Isolation Forest
</td>
<td>
0.769121
</td>
<td>
0.369132
</td>
<td>
0.498847
</td>
<td>
0.670050
</td>
<td>
0.414882
</td>
</tr>
<tr>
<th>
7
</th>
<td>
Deep Autoencoder
</td>
<td>
0.906161
</td>
<td>
0.046605
</td>
<td>
0.088650
</td>
<td>
0.981710
</td>
<td>
0.878009
</td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="models-comparison" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="models-comparison">Models Comparison</h2>
<ul>
<li>Supervised models <strong>outperform</strong> unsupervised</li>
<li>Unsupervised useful for <strong>unknown</strong> attacks</li>
<li>Supervised highest <strong>accuracy</strong></li>
<li>Autoencoder best unsupervised</li>
<li>Statistical weakest coverage</li>
<li>RF strongest overall detector</li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>When comparing all modeling approaches, supervised methods clearly performed the best overall, offering the highest accuracy and the most reliable detection across attack categories. Unsupervised models still play an important role, particularly for detecting new or previously unseen attack patterns, but their precision and consistency are lower. Among the unsupervised models, the Autoencoder showed the strongest capability, while simple statistical techniques provided the weakest coverage and struggled with complex behaviors. Random Forest emerged as the strongest individual model in the entire evaluation, combining accuracy, stability, and interpretability.</p>
</div></div></section>
<section id="discussion" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="discussion">Discussion</h2>
<p><strong>How effectively can unsupervised anomaly detection identify malicious traffic?</strong></p>
<ul>
<li>Trained only on <strong>normal traffic</strong></li>
<li>Detects <strong>high-variance anomalies</strong></li>
<li>Misses <strong>subtle or stealth attacks</strong></li>
<li>Useful for <strong>unknown threats</strong></li>
<li>Requires <strong>threshold tuning</strong></li>
<li>Moderately effective overall</li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>Unsupervised anomaly detection methods can identify attacks that significantly deviate from normal behavior, especially high-variance or clearly abnormal patterns. However, they struggle with low-signal attacks that resemble legitimate traffic, leading to missed detections. Their strength lies in detecting unknown or emerging threats where labeled data is unavailable, but their performance is inconsistent without careful threshold calibration. Overall, unsupervised methods are moderately effective but insufficient as a standalone intrusion detection strategy.</p>
</div></div></section>
<section id="discussion-1" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="discussion-1">Discussion</h2>
<p><strong>How do supervised ML models compare with statistical anomaly detectors?</strong></p>
<ul>
<li>Supervised achieve <strong>higher accuracy</strong></li>
<li>Stronger <strong>precision</strong> and <strong>recall</strong></li>
<li>Better <strong>class separation</strong></li>
<li>Statistical models detect only <strong>simple outliers</strong></li>
<li>Supervised offer <strong>clearer interpretability</strong></li>
<li>More reliable for <strong>operational IDS</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>Supervised machine learning models significantly outperform statistical anomaly detection methods across all major evaluation metrics. They deliver higher accuracy, stronger precision and recall, and more consistent detection of diverse attack types. Statistical methods, such as Z-score, IQR, and Mahalanobis distance, catch only basic or extreme outliers and fail to capture complex attack behaviors. Supervised models also provide clearer interpretability through feature importance and decision boundary analysis, making them far easier for analysts to validate and operationalize. Overall, supervised learning offers far superior intrusion detection performance and reliability in real-world environments.</p>
</div></div></section>
<section id="discussion-2" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="discussion-2">Discussion</h2>
<ul>
<li>Unsupervised moderately <strong>effective</strong></li>
<li>Detects only <strong>high-variance</strong> anomalies</li>
<li>Struggles with <strong>low-signal</strong> attacks</li>
<li>Supervised significantly <strong>stronger</strong></li>
<li>Higher <strong>precision</strong> and <strong>recall</strong></li>
<li>Better overall <strong>interpretability</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>Overall, the results show that unsupervised methods are moderately effective but mainly detect anomalies that are large or highly unusual. They tend to miss low-signal or stealthy attacks that blend in with normal traffic. In contrast, supervised models performed significantly better across all key metrics, including precision and recall, and provided clearer interpretability for analysts. This makes them more dependable for operational use when labeled data is available. The comparison highlights that while unsupervised models add value for discovering unknown threats, supervised learning remains the stronger and more reliable foundation for intrusion detection.</p>
</div></div></section>
<section id="overall-trade-off" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="overall-trade-off">Overall Trade-Off</h2>
<ul>
<li>Supervised: high <strong>accuracy</strong>, low flexibility</li>
<li>Unsupervised: high <strong>adaptability</strong>, lower precision</li>
<li>Statistical: fast, <strong>low insight</strong></li>
<li>Supervised requires <strong>maintenance</strong></li>
<li>Unsupervised requires <strong>threshold tuning</strong></li>
<li>Trade-off: precision vs <strong>generalization</strong></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>Each modeling approach comes with strengths and trade-offs. Supervised models deliver high accuracy and strong predictive power, but they depend on labeled data and require ongoing maintenance as network behavior evolves. Unsupervised models are more flexible and adaptable, making them valuable for detecting unfamiliar threats, but they generally produce lower precision and require careful threshold tuning. Statistical methods are fast and simple to deploy, yet they offer limited insight and struggle with complex attack patterns. Ultimately, the decision comes down to balancing precision against generalization, depending on the organization’s operational needs and risk tolerance.</p>
</div></div></section>
<section id="real-world-implications" class="level2 scrollable page-columns page-full" data-transition="fade-in slide-out" data-transition-speed="slow">
<h2 class="scrollable anchored" data-transition="fade-in slide-out" data-transition-speed="slow" data-anchor-id="real-world-implications">Real-World Implications</h2>
<ul>
<li>Manage <strong>false positives</strong> proactively</li>
<li>Adjust <strong>alert thresholds</strong> regularly</li>
<li>Plan periodic <strong>model retraining</strong></li>
<li>Monitor <strong>concept drift</strong> indicators</li>
<li>Combine supervised + unsupervised</li>
<li>Strengthen SOC <strong>decision support</strong></li>
</ul>



<div class="no-row-height column-margin column-container"><div class="margin-aside">
<p>These findings translate into several practical considerations for real-world intrusion detection. First, managing false positives is essential to prevent analyst fatigue and ensure SOC efficiency. Alert thresholds should be reviewed and adjusted regularly, especially for unsupervised models that are sensitive to behavioral shifts. Models must be retrained periodically to stay aligned with evolving network patterns and avoid degradation from concept drift. A hybrid strategy—combining supervised and unsupervised techniques—can offer both strong accuracy and adaptability. Altogether, these practices enhance SOC decision-making and support more resilient and proactive cybersecurity operations.</p>
</div></div></section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>